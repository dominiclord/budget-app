{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _environment = require('./utils/environment');\n\nvar _ractiveEventsTap = require('./ractive/ractive-events-tap');\n\nvar _ractiveEventsTap2 = _interopRequireDefault(_ractiveEventsTap);\n\nvar _ractiveTransitionsFade = require('./ractive/ractive-transitions-fade');\n\nvar _ractiveTransitionsFade2 = _interopRequireDefault(_ractiveTransitionsFade);\n\nvar _ractiveLoad = require('./ractive/ractive-load');\n\nvar _ractiveLoad2 = _interopRequireDefault(_ractiveLoad);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } /* jshint esnext: true */\n\n\nvar App = function App() {\n    _classCallCheck(this, App);\n\n    /**\n     * Create a new transaction (form and event management)\n     */\n    var newTransactionController;\n\n    Ractive.load('assets/templates/NewTransaction.html').then(function (NewTransactionView) {\n        // NewTransactionView is a constructor that extends Ractive\n        // i.e. NewTransactionView = Ractive.extend({...})\n        newTransactionController = new NewTransactionView({\n            el: '#newTransaction',\n            data: {\n                headerTitle: 'New transaction'\n            }\n        });\n\n        initNewTransactionController();\n    }).catch(function (err) {\n        // the setTimeout ensures the error doesn't get swallowed\n        // (this can be a problem with promises...)\n        setTimeout(function (err) {\n            throw err;\n        });\n    });\n\n    function initNewTransactionController() {}\n    // newTransactionController.on( 'newTransaction', function ( transaction ) {\n    //     console.log( 'saving to server...', transaction );\n\n    //     var jqxhr = $.ajax({\n    //         method: 'POST',\n    //         url: '/api/v1/transactions',\n    //         data: transaction\n    //     })\n    //     .done(function(response) {\n    //         console.log(response.message);\n\n    //         if (response.status === 'ok') {\n    //             console.log(response.results);\n    //         }\n    //     })\n    //     .fail(function() {\n    //         console.log('error');\n    //     })\n    //     .always(function() {\n    //         console.log('finished');\n    //     });\n    // });\n\n\n    /**\n     * Display recent transactions list\n     */\n    var recentTransactionsController;\n\n    Ractive.load('assets/templates/RecentTransactions.html').then(function (RecentTransactionsView) {\n        // NewTransactionView is a constructor that extends Ractive\n        // i.e. NewTransactionView = Ractive.extend({...})\n        recentTransactionsController = new RecentTransactionsView({\n            el: '#recentTransactions',\n            data: {\n                transactions: [],\n                sort: function sort(array, column) {\n                    array = array.slice(); // clone, so we don't modify the underlying data\n\n                    return array.sort(function (a, b) {\n                        return a[column] < b[column] ? 1 : -1;\n                    });\n                },\n                sortColumn: 'creation_date'\n            }\n        });\n\n        recentTransactionsController.on('sort', function (event, column) {\n            this.set('sortColumn', column);\n        });\n\n        initRecentTransactionsController();\n    }).catch(function (err) {\n        setTimeout(function (err) {\n            throw err;\n        });\n    });\n\n    function initRecentTransactionsController() {\n        console.log('Loading recent transactions');\n\n        var jqxhr = $.ajax({\n            method: 'GET',\n            url: '/api/v1/transactions',\n            data: {\n                count: 5\n            }\n        }).done(function (response) {\n            console.log(response.message);\n\n            if (response.status === 'ok') {\n                recentTransactionsController.set('transactions', response.results);\n            }\n        }).fail(function () {\n            console.log('error');\n        }).always(function () {\n            console.log('finished');\n        });\n\n        newTransactionController.on('newTransactionSaved', function (transaction) {\n            recentTransactionsController.push('transactions', transaction);\n        });\n    }\n};\n\nnew App();\n\n},{\"./ractive/ractive-events-tap\":2,\"./ractive/ractive-load\":3,\"./ractive/ractive-transitions-fade\":4,\"./utils/environment\":5}],2:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar DISTANCE_THRESHOLD = 5; // maximum pixels pointer can move before cancel\nvar TIME_THRESHOLD = 400; // maximum milliseconds between down and up before cancel\n\nfunction tap(node, callback) {\n    return new TapHandler(node, callback);\n}\n\nfunction TapHandler(node, callback) {\n    this.node = node;\n    this.callback = callback;\n\n    this.preventMousedownEvents = false;\n\n    this.bind(node);\n}\n\nTapHandler.prototype = {\n    bind: function bind(node) {\n        // listen for mouse/pointer events...\n        if (window.navigator.pointerEnabled) {\n            node.addEventListener('pointerdown', handleMousedown, false);\n        } else if (window.navigator.msPointerEnabled) {\n            node.addEventListener('MSPointerDown', handleMousedown, false);\n        } else {\n            node.addEventListener('mousedown', handleMousedown, false);\n        }\n\n        // ...and touch events\n        node.addEventListener('touchstart', handleTouchstart, false);\n\n        // native buttons, and <input type='button'> elements, should fire a tap event\n        // when the space key is pressed\n        if (node.tagName === 'BUTTON' || node.type === 'button') {\n            node.addEventListener('focus', handleFocus, false);\n        }\n\n        node.__tap_handler__ = this;\n    },\n    fire: function fire(event, x, y) {\n        this.callback({\n            node: this.node,\n            original: event,\n            x: x,\n            y: y\n        });\n    },\n    mousedown: function mousedown(event) {\n        var _this = this;\n\n        if (this.preventMousedownEvents) {\n            return;\n        }\n\n        if (event.which !== undefined && event.which !== 1) {\n            return;\n        }\n\n        var x = event.clientX;\n        var y = event.clientY;\n\n        // This will be null for mouse events.\n        var pointerId = event.pointerId;\n\n        var handleMouseup = function handleMouseup(event) {\n            if (event.pointerId != pointerId) {\n                return;\n            }\n\n            _this.fire(event, x, y);\n            cancel();\n        };\n\n        var handleMousemove = function handleMousemove(event) {\n            if (event.pointerId != pointerId) {\n                return;\n            }\n\n            if (Math.abs(event.clientX - x) >= DISTANCE_THRESHOLD || Math.abs(event.clientY - y) >= DISTANCE_THRESHOLD) {\n                cancel();\n            }\n        };\n\n        var cancel = function cancel() {\n            _this.node.removeEventListener('MSPointerUp', handleMouseup, false);\n            document.removeEventListener('MSPointerMove', handleMousemove, false);\n            document.removeEventListener('MSPointerCancel', cancel, false);\n            _this.node.removeEventListener('pointerup', handleMouseup, false);\n            document.removeEventListener('pointermove', handleMousemove, false);\n            document.removeEventListener('pointercancel', cancel, false);\n            _this.node.removeEventListener('click', handleMouseup, false);\n            document.removeEventListener('mousemove', handleMousemove, false);\n        };\n\n        if (window.navigator.pointerEnabled) {\n            this.node.addEventListener('pointerup', handleMouseup, false);\n            document.addEventListener('pointermove', handleMousemove, false);\n            document.addEventListener('pointercancel', cancel, false);\n        } else if (window.navigator.msPointerEnabled) {\n            this.node.addEventListener('MSPointerUp', handleMouseup, false);\n            document.addEventListener('MSPointerMove', handleMousemove, false);\n            document.addEventListener('MSPointerCancel', cancel, false);\n        } else {\n            this.node.addEventListener('click', handleMouseup, false);\n            document.addEventListener('mousemove', handleMousemove, false);\n        }\n\n        setTimeout(cancel, TIME_THRESHOLD);\n    },\n    touchdown: function touchdown() {\n        var _this2 = this;\n\n        var touch = event.touches[0];\n\n        var x = touch.clientX;\n        var y = touch.clientY;\n\n        var finger = touch.identifier;\n\n        var handleTouchup = function handleTouchup(event) {\n            var touch = event.changedTouches[0];\n\n            if (touch.identifier !== finger) {\n                cancel();\n                return;\n            }\n\n            event.preventDefault(); // prevent compatibility mouse event\n\n            // for the benefit of mobile Firefox and old Android browsers, we need this absurd hack.\n            _this2.preventMousedownEvents = true;\n            clearTimeout(_this2.preventMousedownTimeout);\n\n            _this2.preventMousedownTimeout = setTimeout(function () {\n                _this2.preventMousedownEvents = false;\n            }, 400);\n\n            _this2.fire(event, x, y);\n            cancel();\n        };\n\n        var handleTouchmove = function handleTouchmove(event) {\n            if (event.touches.length !== 1 || event.touches[0].identifier !== finger) {\n                cancel();\n            }\n\n            var touch = event.touches[0];\n            if (Math.abs(touch.clientX - x) >= DISTANCE_THRESHOLD || Math.abs(touch.clientY - y) >= DISTANCE_THRESHOLD) {\n                cancel();\n            }\n        };\n\n        var cancel = function cancel() {\n            _this2.node.removeEventListener('touchend', handleTouchup, false);\n            window.removeEventListener('touchmove', handleTouchmove, false);\n            window.removeEventListener('touchcancel', cancel, false);\n        };\n\n        this.node.addEventListener('touchend', handleTouchup, false);\n        window.addEventListener('touchmove', handleTouchmove, false);\n        window.addEventListener('touchcancel', cancel, false);\n\n        setTimeout(cancel, TIME_THRESHOLD);\n    },\n    teardown: function teardown() {\n        var node = this.node;\n\n        node.removeEventListener('pointerdown', handleMousedown, false);\n        node.removeEventListener('MSPointerDown', handleMousedown, false);\n        node.removeEventListener('mousedown', handleMousedown, false);\n        node.removeEventListener('touchstart', handleTouchstart, false);\n        node.removeEventListener('focus', handleFocus, false);\n    }\n};\n\nfunction handleMousedown(event) {\n    this.__tap_handler__.mousedown(event);\n}\n\nfunction handleTouchstart(event) {\n    this.__tap_handler__.touchdown(event);\n}\n\nfunction handleFocus() {\n    this.addEventListener('keydown', handleKeydown, false);\n    this.addEventListener('blur', handleBlur, false);\n}\n\nfunction handleBlur() {\n    this.removeEventListener('keydown', handleKeydown, false);\n    this.removeEventListener('blur', handleBlur, false);\n}\n\nfunction handleKeydown(event) {\n    if (event.which === 32) {\n        // space key\n        this.__tap_handler__.fire();\n    }\n}\n\nexports.default = tap;\n\n},{}],3:[function(require,module,exports){\n(function (process,Buffer){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _ractive = (typeof window !== \"undefined\" ? window['Ractive'] : typeof global !== \"undefined\" ? global['Ractive'] : null);\n\nvar _ractive2 = _interopRequireDefault(_ractive);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getName(path) {\n    var pathParts, filename, lastIndex;\n\n    pathParts = path.split('/');\n    filename = pathParts.pop();\n\n    lastIndex = filename.lastIndexOf('.');\n    if (lastIndex !== -1) {\n        filename = filename.substr(0, lastIndex);\n    }\n\n    return filename;\n}\n\n/**\n * Finds the line and column position of character `char`\n   in a (presumably) multi-line string\n * @param {array} lines - an array of strings, each representing\n   a line of the original string\n * @param {number} char - the character index to convert\n * @returns {object}\n     * @property {number} line - the zero-based line index\n     * @property {number} column - the zero-based column index\n     * @property {number} char - the character index that was passed in\n */\nfunction getLinePosition(lines, char) {\n    var line = 0;\n    var lineStart = 0;\n\n    var lineEnds = lines.map(function (line) {\n        var lineEnd = lineStart + line.length + 1; // +1 for the newline\n\n        lineStart = lineEnd;\n        return lineEnd;\n    });\n\n    lineStart = 0;\n\n    while (char >= lineEnds[line]) {\n        lineStart = lineEnds[line];\n        line += 1;\n    }\n\n    var column = char - lineStart;\n    return { line: line, column: column, char: char };\n}\n\nvar requirePattern = /require\\s*\\(\\s*(?:\"([^\"]+)\"|'([^']+)')\\s*\\)/g;\nvar TEMPLATE_VERSION = 3;\n\nfunction parse(source) {\n    var parsed, template, links, imports, scriptItem, script, styles, match, modules, i, item, result;\n\n    if (!rcu.Ractive) {\n        throw new Error('rcu has not been initialised! You must call rcu.init(Ractive) before rcu.parse()');\n    }\n\n    parsed = rcu.Ractive.parse(source, {\n        noStringify: true,\n        interpolate: { script: false, style: false },\n        includeLinePositions: true\n    });\n\n    if (parsed.v !== TEMPLATE_VERSION) {\n        throw new Error('Mismatched template version (expected ' + TEMPLATE_VERSION + ', got ' + parsed.v + ')! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app');\n    }\n\n    links = [];\n    styles = [];\n    modules = [];\n\n    // Extract certain top-level nodes from the template. We work backwards\n    // so that we can easily splice them out as we go\n    template = parsed.t;\n    i = template.length;\n    while (i--) {\n        item = template[i];\n\n        if (item && item.t === 7) {\n            if (item.e === 'link' && item.a && item.a.rel === 'ractive') {\n                links.push(template.splice(i, 1)[0]);\n            }\n\n            if (item.e === 'script' && (!item.a || !item.a.type || item.a.type === 'text/javascript')) {\n                if (scriptItem) {\n                    throw new Error('You can only have one <script> tag per component file');\n                }\n                scriptItem = template.splice(i, 1)[0];\n            }\n\n            if (item.e === 'style' && (!item.a || !item.a.type || item.a.type === 'text/css')) {\n                styles.push(template.splice(i, 1)[0]);\n            }\n        }\n    }\n\n    // Clean up template - trim whitespace left over from the removal\n    // of <link>, <style> and <script> tags from start...\n    while (/^\\s*$/.test(template[0])) {\n        template.shift();\n    }\n\n    // ...and end\n    while (/^\\s*$/.test(template[template.length - 1])) {\n        template.pop();\n    }\n\n    // Extract names from links\n    imports = links.map(function (link) {\n        var href = link.a.href;\n        var name = link.a.name || getName(href);\n\n        if (typeof name !== 'string') {\n            throw new Error('Error parsing link tag');\n        }\n\n        return { name: name, href: href };\n    });\n\n    result = {\n        source: source, imports: imports, modules: modules,\n        template: parsed,\n        css: styles.map(extractFragment).join(' '),\n        script: ''\n    };\n\n    // extract position information, so that we can generate source maps\n    if (scriptItem) {\n        var content = scriptItem.f[0];\n\n        var contentStart = source.indexOf('>', scriptItem.p[2]) + 1;\n\n        // we have to jump through some hoops to find contentEnd, because the contents\n        // of the <script> tag get trimmed at parse time\n        var contentEnd = contentStart + content.length + source.slice(contentStart).replace(content, '').indexOf('</script');\n\n        var lines = source.split('\\n');\n\n        result.scriptStart = getLinePosition(lines, contentStart);\n        result.scriptEnd = getLinePosition(lines, contentEnd);\n\n        result.script = source.slice(contentStart, contentEnd);\n\n        while (match = requirePattern.exec(result.script)) {\n            modules.push(match[1] || match[2]);\n        }\n    }\n\n    return result;\n}\n\nfunction extractFragment(item) {\n    return item.f;\n}\n\nvar _eval;\nvar isBrowser;\nvar isNode;\nvar head;\nvar Module;\nvar base64Encode;\nvar SOURCE_MAPPING_URL = 'sourceMappingUrl';\nvar DATA = 'data';\n\n// This causes code to be eval'd in the global scope\n_eval = eval;\n\nif (typeof document !== 'undefined') {\n    isBrowser = true;\n    head = document.getElementsByTagName('head')[0];\n} else if (typeof process !== 'undefined') {\n    isNode = true;\n    Module = (require.nodeRequire || require)('module');\n}\n\nif (typeof btoa === 'function') {\n    base64Encode = function base64Encode(str) {\n        str = str.replace(/[^\\x00-\\x7F]/g, function (char) {\n            var hex = char.charCodeAt(0).toString(16);\n            while (hex.length < 4) {\n                hex = '0' + hex;\n            }return '\\\\u' + hex;\n        });\n\n        return btoa(str);\n    };\n} else if (typeof Buffer === 'function') {\n    base64Encode = function base64Encode(str) {\n        return new Buffer(str, 'utf-8').toString('base64');\n    };\n} else {\n    base64Encode = function base64Encode() {};\n}\n\nfunction eval2(script, options) {\n    options = options || {};\n\n    if (options.sourceMap) {\n        script += '\\n//# ' + SOURCE_MAPPING_URL + '=data:application/json;charset=utf-8;base64,' + base64Encode(JSON.stringify(options.sourceMap));\n    } else if (options.sourceURL) {\n        script += '\\n//# sourceURL=' + options.sourceURL;\n    }\n\n    try {\n        return _eval(script);\n    } catch (err) {\n        if (isNode) {\n            locateErrorUsingModule(script, options.sourceURL || '');\n            return;\n        }\n\n        // In browsers, only locate syntax errors. Other errors can\n        // be located via the console in the normal fashion\n        else if (isBrowser && err.name === 'SyntaxError') {\n                locateErrorUsingDataUri(script);\n            }\n\n        throw err;\n    }\n}\n\neval2.Function = function () {\n    var arguments$1 = arguments;\n\n    var i,\n        args = [],\n        body,\n        wrapped,\n        options;\n\n    i = arguments.length;\n    while (i--) {\n        args[i] = arguments$1[i];\n    }\n\n    if (_typeof(args[args.length - 1]) === 'object') {\n        options = args.pop();\n    } else {\n        options = {};\n    }\n\n    // allow an array of arguments to be passed\n    if (args.length === 1 && Object.prototype.toString.call(args) === '[object Array]') {\n        args = args[0];\n    }\n\n    if (options.sourceMap) {\n        options.sourceMap = clone(options.sourceMap);\n\n        // shift everything a line down, to accommodate `(function (...) {`\n        options.sourceMap.mappings = ';' + options.sourceMap.mappings;\n    }\n\n    body = args.pop();\n    wrapped = '(function (' + args.join(', ') + ') {\\n' + body + '\\n})';\n\n    return eval2(wrapped, options);\n};\n\nfunction locateErrorUsingDataUri(code) {\n    var dataURI, scriptElement;\n\n    dataURI = DATA + ':text/javascript;charset=utf-8,' + encodeURIComponent(code);\n\n    scriptElement = document.createElement('script');\n    scriptElement.src = dataURI;\n\n    scriptElement.onload = function () {\n        head.removeChild(scriptElement);\n    };\n\n    head.appendChild(scriptElement);\n}\n\nfunction locateErrorUsingModule(code, url) {\n    var m = new Module();\n\n    try {\n        m._compile('module.exports = function () {\\n' + code + '\\n};', url);\n    } catch (err) {\n        console.error(err);\n        return;\n    }\n\n    m.exports();\n}\n\nfunction clone(obj) {\n    var cloned = {},\n        key;\n\n    for (key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            cloned[key] = obj[key];\n        }\n    }\n\n    return cloned;\n}\n\nvar charToInteger = {};\nvar integerToChar = {};\n\n'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('').forEach(function (char, i) {\n    charToInteger[char] = i;\n    integerToChar[i] = char;\n});\n\nfunction encode(value) {\n    var result, i;\n\n    if (typeof value === 'number') {\n        result = encodeInteger(value);\n    } else {\n        result = '';\n        for (i = 0; i < value.length; i += 1) {\n            result += encodeInteger(value[i]);\n        }\n    }\n\n    return result;\n}\n\nfunction encodeInteger(num) {\n    var result = '',\n        clamped;\n\n    if (num < 0) {\n        num = -num << 1 | 1;\n    } else {\n        num <<= 1;\n    }\n\n    do {\n        clamped = num & 31;\n        num >>= 5;\n\n        if (num > 0) {\n            clamped |= 32;\n        }\n\n        result += integerToChar[clamped];\n    } while (num > 0);\n\n    return result;\n}\n\n/**\n * Encodes a string as base64\n * @param {string} str - the string to encode\n * @returns {string}\n */\nfunction btoa$1(str) {\n    return new Buffer(str).toString('base64');\n}\n\nvar SourceMap = function SourceMap(properties) {\n    this.version = 3;\n\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = properties.mappings;\n};\n\nSourceMap.prototype = {\n    toString: function toString() {\n        return JSON.stringify(this);\n    },\n\n    toUrl: function toUrl() {\n        return 'data:application/json;charset=utf-8;base64,' + btoa$1(this.toString());\n    }\n};\n\nvar alreadyWarned = false;\n\n/**\n * Generates a v3 sourcemap between an original source and its built form\n * @param {object} definition - the result of `rcu.parse( originalSource )`\n * @param {object} options\n * @param {string} options.source - the name of the original source file\n * @param {number=} options.offset - the number of lines in the generated\n   code that precede the script portion of the original source\n * @param {string=} options.file - the name of the generated file\n * @returns {object}\n */\nfunction generateSourceMap(definition, options) {\n    var lines, mappings, offset;\n\n    if (!options || !options.source) {\n        throw new Error('You must supply an options object with a `source` property to rcu.generateSourceMap()');\n    }\n\n    if ('padding' in options) {\n        options.offset = options.padding;\n\n        if (!alreadyWarned) {\n            console.log('rcu: options.padding is deprecated, use options.offset instead');\n            alreadyWarned = true;\n        }\n    }\n\n    // The generated code probably includes a load of module gubbins - we don't bother\n    // mapping that to anything, instead we just have a bunch of empty lines\n    offset = new Array((options.offset || 0) + 1).join(';');\n\n    lines = definition.script.split('\\n');\n    mappings = offset + lines.map(function (line, i) {\n        if (i === 0) {\n            // first mapping points to code immediately following opening <script> tag\n            return encode([0, 0, definition.scriptStart.line, definition.scriptStart.column]);\n        }\n\n        if (i === 1) {\n            return encode([0, 0, 1, -definition.scriptStart.column]);\n        }\n\n        return 'AACA'; // equates to [ 0, 0, 1, 0 ];\n    }).join(';');\n\n    return new SourceMap({\n        file: options.file,\n        sources: [options.source],\n        sourcesContent: [definition.source],\n        names: [],\n        mappings: mappings\n    });\n}\n\nfunction make(source, config, callback, errback) {\n    var definition, url, createComponent, loadImport, imports, loadModule, modules, remainingDependencies, onloaded, ready;\n\n    config = config || {};\n\n    // Implementation-specific config\n    url = config.url || '';\n    loadImport = config.loadImport;\n    loadModule = config.loadModule;\n\n    definition = parse(source);\n\n    createComponent = function createComponent() {\n        var options, Component, factory, component, exports, prop;\n\n        options = {\n            template: definition.template,\n            partials: definition.partials,\n            css: definition.css,\n            components: imports\n        };\n\n        if (definition.script) {\n            var sourceMap = generateSourceMap(definition, {\n                source: url,\n                content: source\n            });\n\n            try {\n                factory = new eval2.Function('component', 'require', 'Ractive', definition.script, {\n                    sourceMap: sourceMap\n                });\n\n                component = {};\n                factory(component, config.require, rcu.Ractive);\n                exports = component.exports;\n\n                if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n                    for (prop in exports) {\n                        if (exports.hasOwnProperty(prop)) {\n                            options[prop] = exports[prop];\n                        }\n                    }\n                }\n\n                Component = rcu.Ractive.extend(options);\n            } catch (err) {\n                errback(err);\n                return;\n            }\n\n            callback(Component);\n        } else {\n            Component = rcu.Ractive.extend(options);\n            callback(Component);\n        }\n    };\n\n    // If the definition includes sub-components e.g.\n    //     <link rel='ractive' href='foo.html'>\n    //\n    // ...then we need to load them first, using the loadImport method\n    // specified by the implementation.\n    //\n    // In some environments (e.g. AMD) the same goes for modules, which\n    // most be loaded before the script can execute\n    remainingDependencies = definition.imports.length + (loadModule ? definition.modules.length : 0);\n\n    if (remainingDependencies) {\n        onloaded = function onloaded() {\n            if (! --remainingDependencies) {\n                if (ready) {\n                    createComponent();\n                } else {\n                    setTimeout(createComponent, 0); // cheap way to enforce asynchrony for a non-Zalgoesque API\n                }\n            }\n        };\n\n        if (definition.imports.length) {\n            if (!loadImport) {\n                throw new Error('Component definition includes imports (e.g. `<link rel=\"ractive\" href=\"' + definition.imports[0].href + '\">`) but no loadImport method was passed to rcu.make()');\n            }\n\n            imports = {};\n\n            definition.imports.forEach(function (toImport) {\n                loadImport(toImport.name, toImport.href, url, function (Component) {\n                    imports[toImport.name] = Component;\n                    onloaded();\n                });\n            });\n        }\n\n        if (loadModule && definition.modules.length) {\n            modules = {};\n\n            definition.modules.forEach(function (name) {\n                loadModule(name, name, url, function (Component) {\n                    modules[name] = Component;\n                    onloaded();\n                });\n            });\n        }\n    } else {\n        setTimeout(createComponent, 0);\n    }\n\n    ready = true;\n}\n\nfunction resolvePath(relativePath, base) {\n    var pathParts, relativePathParts, part;\n\n    // If we've got an absolute path, or base is '', return\n    // relativePath\n    if (!base || relativePath.charAt(0) === '/') {\n        return relativePath;\n    }\n\n    // 'foo/bar/baz.html' -> ['foo', 'bar', 'baz.html']\n    pathParts = (base || '').split('/');\n    relativePathParts = relativePath.split('/');\n\n    // ['foo', 'bar', 'baz.html'] -> ['foo', 'bar']\n    pathParts.pop();\n\n    while (part = relativePathParts.shift()) {\n        if (part === '..') {\n            pathParts.pop();\n        } else if (part !== '.') {\n            pathParts.push(part);\n        }\n    }\n\n    return pathParts.join('/');\n}\n\nvar rcu = {\n    init: function init(copy) {\n        rcu.Ractive = copy;\n    },\n\n    parse: parse,\n    make: make,\n    generateSourceMap: generateSourceMap,\n    resolve: resolvePath,\n    getName: getName\n};\n\nvar get;\n\n// Test for XHR to see if we're in a browser...\nif (typeof XMLHttpRequest !== 'undefined') {\n    get = function get(url) {\n        return new _ractive2.default.Promise(function (fulfil, reject) {\n            var xhr, onload, loaded;\n\n            xhr = new XMLHttpRequest();\n            xhr.open('GET', url);\n\n            onload = function onload() {\n                if (xhr.readyState !== 4 || loaded) {\n                    return;\n                }\n\n                fulfil(xhr.responseText);\n                loaded = true;\n            };\n\n            xhr.onload = xhr.onreadystatechange = onload;\n            xhr.onerror = reject;\n            xhr.send();\n\n            if (xhr.readyState === 4) {\n                onload();\n            }\n        });\n    };\n}\n\n// ...or in node.js\nelse {\n        get = function get(url) {\n            return new _ractive2.default.Promise(function (fulfil, reject) {\n                require('fs').readFile(url, function (err, result) {\n                    if (err) {\n                        return reject(err);\n                    }\n\n                    fulfil(result.toString());\n                });\n            });\n        };\n    }\n\nvar get$1 = get;\n\nvar promises = {};\nvar global = typeof window !== 'undefined' ? window : {};\n// Load a single component:\n//\n//     Ractive.load( 'path/to/foo' ).then( function ( Foo ) {\n//       var foo = new Foo(...);\n//     });\nfunction loadSingle(path, parentUrl, baseUrl, cache) {\n    var promise, url;\n\n    url = rcu.resolve(path, path[0] === '.' ? parentUrl : baseUrl);\n\n    // if this component has already been requested, don't\n    // request it again\n    if (!cache || !promises[url]) {\n        promise = get$1(url).then(function (template) {\n            return new _ractive2.default.Promise(function (fulfil, reject) {\n                rcu.make(template, {\n                    url: url,\n                    loadImport: function loadImport(name, path, parentUrl, callback) {\n                        // if import has a relative URL, it should resolve\n                        // relative to this (parent). Otherwise, relative\n                        // to load.baseUrl\n                        loadSingle(path, parentUrl, baseUrl, cache).then(callback, reject);\n                    },\n                    require: ractiveRequire\n                }, fulfil, reject);\n            });\n        });\n\n        promises[url] = promise;\n    }\n\n    return promises[url];\n}\n\nfunction ractiveRequire(name) {\n    var dependency, qualified;\n\n    dependency = load.modules.hasOwnProperty(name) ? load.modules[name] : global.hasOwnProperty(name) ? global[name] : null;\n\n    if (!dependency && typeof require === 'function') {\n        try {\n            dependency = require(name);\n        } catch (e) {\n            if (typeof process !== 'undefined') {\n                dependency = require(process.cwd() + '/' + name);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    if (!dependency) {\n        qualified = !/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(name) ? '[\"' + name + '\"]' : '.' + name;\n        throw new Error('Ractive.load() error: Could not find dependency \"' + name + '\". It should be exposed as Ractive.load.modules' + qualified + ' or window' + qualified);\n    }\n\n    return dependency;\n}\n\n// Create globally-available components from links found on the page:\n//\n//     <link rel='ractive' href='path/to/foo.html'>\n//\n// You can optionally add a name attribute, otherwise the file name (in\n// the example above, 'foo') will be used instead. The component will\n// be available as `Ractive.components.foo`:\n//\n//     Ractive.load().then( function () {\n//       var foo = new Ractive.components.foo(...);\n//     });\nfunction loadFromLinks(baseUrl, cache) {\n    var promise = new _ractive2.default.Promise(function (resolve, reject) {\n        var links, pending;\n\n        links = toArray(document.querySelectorAll('link[rel=\"ractive\"]'));\n        pending = links.length;\n\n        links.forEach(function (link) {\n            var name = getNameFromLink(link);\n\n            loadSingle(link.getAttribute('href'), '', baseUrl, cache).then(function (Component) {\n                _ractive2.default.components[name] = Component;\n\n                if (! --pending) {\n                    resolve();\n                }\n            }, reject);\n        });\n    });\n\n    return promise;\n}\n\nfunction getNameFromLink(link) {\n    return link.getAttribute('name') || rcu.getName(link.getAttribute('href'));\n}\n\nfunction toArray(arrayLike) {\n    var arr = [],\n        i = arrayLike.length;\n\n    while (i--) {\n        arr[i] = arrayLike[i];\n    }\n\n    return arr;\n}\n\n// Load multiple components:\n//\n//     Ractive.load({\n//       foo: 'path/to/foo.html',\n//       bar: 'path/to/bar.html'\n//     }).then( function ( components ) {\n//       var foo = new components.foo(...);\n//       var bar = new components.bar(...);\n//     });\nfunction loadMultiple(map, baseUrl, cache) {\n    var promise = new _ractive2.default.Promise(function (resolve, reject) {\n        var pending = 0,\n            result = {},\n            name,\n            load;\n\n        load = function load(name) {\n            var path = map[name];\n\n            loadSingle(path, baseUrl, baseUrl, cache).then(function (Component) {\n                result[name] = Component;\n\n                if (! --pending) {\n                    resolve(result);\n                }\n            }, reject);\n        };\n\n        for (name in map) {\n            if (map.hasOwnProperty(name)) {\n                pending += 1;\n                load(name);\n            }\n        }\n    });\n\n    return promise;\n}\n\nrcu.init(_ractive2.default);\n\nfunction load(url) {\n    var baseUrl = load.baseUrl;\n    var cache = load.cache !== false;\n\n    if (!url) {\n        return loadFromLinks(baseUrl, cache);\n    }\n\n    if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === 'object') {\n        return loadMultiple(url, baseUrl, cache);\n    }\n\n    return loadSingle(url, baseUrl, baseUrl, cache);\n}\n\nload.baseUrl = '';\nload.modules = {};\n\nexports.default = load;\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":11,\"buffer\":8,\"fs\":7}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar DEFAULTS = {\n    delay: 0,\n    duration: 300,\n    easing: 'linear'\n};\n\nfunction fade(t, params) {\n    var targetOpacity;\n\n    params = t.processParams(params, DEFAULTS);\n\n    if (t.isIntro) {\n        targetOpacity = t.getStyle('opacity');\n        t.setStyle('opacity', 0);\n    } else {\n        targetOpacity = 0;\n    }\n\n    t.animateStyle('opacity', targetOpacity, params).then(t.complete);\n}\n\nexports.default = fade;\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar $document = $(document);\nvar $window = $(window);\nvar $html = $(document.documentElement);\nvar $body = $(document.body);\n\nexports.$document = $document;\nexports.$window = $window;\nexports.$html = $html;\nexports.$body = $body;\n\n},{}],6:[function(require,module,exports){\n'use strict'\n\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nfunction init () {\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i]\n    revLookup[code.charCodeAt(i)] = i\n  }\n\n  revLookup['-'.charCodeAt(0)] = 62\n  revLookup['_'.charCodeAt(0)] = 63\n}\n\ninit()\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n\n  // base64 is 4/3 + up to two characters of the original data\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n},{}],7:[function(require,module,exports){\n\n},{}],8:[function(require,module,exports){\n(function (global){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var foundIndex = -1\n  for (var i = 0; byteOffset + i < arrLength; i++) {\n    if (read(arr, byteOffset + i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n      if (foundIndex === -1) foundIndex = i\n      if (i - foundIndex + 1 === valLength) return (byteOffset + foundIndex) * indexSize\n    } else {\n      if (foundIndex !== -1) i -= i - foundIndex\n      foundIndex = -1\n    }\n  }\n  return -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  if (Buffer.isBuffer(val)) {\n    // special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(this, val, byteOffset, encoding)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset, encoding)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; i++) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"base64-js\":6,\"ieee754\":10,\"isarray\":9}],9:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],10:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],11:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}]},{},[1]);\n"],"file":"app.js","sourceRoot":"/source/"}